"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  default: () => Client,
  init: () => init
});
module.exports = __toCommonJS(src_exports);

// src/core/init.ts
var import_puppeteer = __toESM(require("puppeteer"));

// src/actions/toConversation.ts
async function toConversation(page, groupName, groupId) {
  const selector = "#main-tab > div:nth-child(1) > div.nav__tabs__top > div.clickable.leftbar-tab.flx.flx-col.flx-al-c.flx-center.rel.selected";
  await page.waitForSelector(selector);
  await page.click(selector);
  await page.type("#contact-search-input", groupName);
  await page.waitForSelector(groupId);
  await page.click(groupId);
}

// src/core/init.ts
var import_express = __toESM(require("express"));
var import_http = __toESM(require("http"));
var import_path = __toESM(require("path"));
var import_socket = require("socket.io");
var import_events = require("events");
var eventEmitter = new import_events.EventEmitter();
var app = (0, import_express.default)();
var server = import_http.default.createServer(app);
var io = new import_socket.Server(server);
async function init(options) {
  const { groupName, groupID, headless = true, port = 3e3 } = options;
  let isLogin = false;
  app.set("view engine", "ejs");
  app.set("views", import_path.default.join(__dirname, "../views"));
  app.use(import_express.default.static(import_path.default.join(__dirname, "public")));
  try {
    const browser = await import_puppeteer.default.launch({ headless });
    const page = await browser.newPage();
    await page.goto("https://id.zalo.me/account?continue=https://chat.zalo.me");
    await page.waitForSelector("#app > div > div.zLogin-layout > div.body > div.animated.fadeIn.body-container > div.content.animated.fadeIn > div > div > div.qrcode > div.qr-container > img");
    ;
    const imageSrc = await page.evaluate(() => {
      const imgElement = document.querySelector("#app > div > div.zLogin-layout > div.body > div.animated.fadeIn.body-container > div.content.animated.fadeIn > div > div > div.qrcode > div.qr-container > img");
      if (imgElement) {
        return imgElement.src;
      } else {
        return null;
      }
    });
    app.get("/", (req, res) => {
      res.render("index", { imageSrc });
    });
    io.on("connection", (socket) => {
      console.log("a user connected");
      socket.on("refreshQR", async () => {
        console.log("Received refreshQR event");
        await page.reload();
      });
      page.on("request", (request) => {
        if (request.url().startsWith("data:image/png;base64")) {
          const imageSrc2 = request.url();
          io.emit("changeImage", imageSrc2);
        }
      });
    });
    page.on("framenavigated", async (frame) => {
      const url = frame.url();
      if (url.startsWith("https://chat.zalo.me/") && !isLogin) {
        isLogin = true;
        await toConversation(page, groupName, "#group-item-" + groupID);
        page.off("framenavigated");
        page.removeAllListeners("request");
        eventEmitter.emit("initialized");
      }
    });
    server.listen(port, () => {
      console.log(`Server is running on port http://localhost:${port}`);
    });
    return { browser, page };
  } catch (error) {
    console.error("Error during initialization:", error);
    throw error;
  }
}

// src/events/messageListener/getAllMessage.ts
var cheerio = __toESM(require("cheerio"));

// src/state/store.ts
var import_toolkit3 = require("@reduxjs/toolkit");

// src/state/userSlice.ts
var import_toolkit = require("@reduxjs/toolkit");
var initialState = {
  name: "",
  bio: "",
  birth: "",
  number: ""
};
var userSlice = (0, import_toolkit.createSlice)({
  name: "user",
  initialState,
  reducers: {
    setName: (state, action) => {
      state.name = action.payload;
    },
    setBio: (state, action) => {
      state.bio = action.payload;
    },
    setBirth: (state, action) => {
      state.birth = action.payload;
    },
    setNumber: (state, action) => {
      state.number = action.payload;
    }
  }
});
var { setName, setBio, setBirth, setNumber } = userSlice.actions;
var userSlice_default = userSlice.reducer;

// src/state/previousNameSlice.ts
var import_toolkit2 = require("@reduxjs/toolkit");
var initialState2 = {
  value: ""
};
var previousNameSlice = (0, import_toolkit2.createSlice)({
  name: "previousName",
  initialState: initialState2,
  reducers: {
    setPreviousName: (state, action) => {
      state.value = action.payload;
    }
  }
});
var { setPreviousName } = previousNameSlice.actions;
var previousNameSlice_default = previousNameSlice.reducer;

// src/state/store.ts
var store = (0, import_toolkit3.configureStore)({
  reducer: {
    user: userSlice_default,
    previousName: previousNameSlice_default
  }
});

// src/events/messageListener/getAllMessage.ts
async function getAllMessage(page, user) {
  const previousName = store.getState().previousName;
  const elements = await page.evaluate(() => {
    const elements2 = document.querySelectorAll("[id*=bb_msg_id_]");
    return Array.from(elements2).map((element) => element.outerHTML);
  });
  const messages = elements.map((element) => {
    const $ = cheerio.load(element);
    const messageId = $(".chat-message").attr("id");
    const time = $(".card-send-time__sendTime").text().trim();
    let content;
    function getName() {
      const isMyMessage = $(".wrap-message").hasClass("me");
      if (isMyMessage) {
        return user?.name;
      } else {
        const senderNameElement = $(".card-sender-name span");
        if (senderNameElement.length > 0) {
          store.dispatch(setPreviousName(senderNameElement.text().trim()));
          return senderNameElement.text().trim();
        } else {
          return previousName;
        }
      }
    }
    const imageMessage = $("div.chatImageMessage");
    if (imageMessage.length > 0) {
      const imageSrc = $("img").attr("src");
      content = imageSrc;
    }
    const textMessage = $("div.card--text");
    if (textMessage.length > 0) {
      content = textMessage.find(".text").text().trim() || void 0;
    }
    const emojiElement = $(".emoji-sizer.emoji-outer.larger");
    if (emojiElement.length > 0) {
      const emojiCode = emojiElement.text();
      content = emojiCode;
    }
    const name = getName();
    return { content, name, messageId, time };
  });
  return messages;
}

// src/events/messageListener/index.ts
async function messageListener(page, callback, user) {
  let isRunning = false;
  page.on("request", async (request) => {
    if (request.url().startsWith("https://tt-group-wpa.chat.zalo.me/api/group/deliveredv2?zpw_ver=628&zpw_type=30") && !isRunning) {
      const startTime = process.hrtime.bigint();
      isRunning = true;
      const messageArray = await getAllMessage(page, user);
      await page.evaluate((messageArray2) => {
        var elementsByClass = document.querySelectorAll(".rel.zavatar-container.avatar--overlay");
        elementsByClass.forEach(function(element) {
          element.remove();
        });
        const messageIdArray = messageArray2.map((obj) => obj.messageId);
        messageIdArray.forEach(function(id) {
          if (id) {
            var element = document.getElementById(id);
            if (element) {
              element.remove();
            }
          }
        });
      }, messageArray);
      if (messageArray.length != 0 && messageArray) {
        callback(messageArray);
      }
      isRunning = false;
    }
  });
}

// src/events/index.ts
var Events = class {
  page;
  user;
  constructor(page) {
    this.page = page;
    this.user = null;
    this.connect();
  }
  connect() {
    eventEmitter.once("scraped", async () => {
      this.user = store.getState().user;
      eventEmitter.emit("ready");
    });
  }
  async on(event, callback) {
    switch (event) {
      case "message":
        eventEmitter.on("ready", () => messageListener(this.page, callback, this.user));
        break;
      default:
        console.log("It's something else.");
    }
  }
  async once(event, callback) {
    switch (event) {
      case "ready":
        eventEmitter.once("ready", () => callback());
        break;
      default:
        console.log("It's something else.");
    }
  }
};

// src/actions/send.ts
var path2 = __toESM(require("path"));
async function sendMessage(page, options) {
  if (!options.message && !options.file || options.message && options.file) {
    throw new Error("Please provide either a message or a file, not both or none.");
  }
  if (options.message) {
    await sendMessageText(page, options.message);
  }
  if (options.file) {
    await sendFile(page, options.file);
  }
}
async function sendMessageText(page, message) {
  await page.waitForSelector("#input_line_0");
  await page.type("#input_line_0", message);
  await page.keyboard.press("Enter");
}
async function sendFile(page, filePath) {
  await page.waitForSelector("#ztoolbar > div:nth-child(2) > i");
  const [fileChooser] = await Promise.all([
    page.waitForFileChooser(),
    page.click("#ztoolbar > div:nth-child(2) > i")
  ]);
  const absolutePath = path2.resolve(filePath);
  await fileChooser.accept([absolutePath]);
}

// src/actions/index.ts
var Actions = class {
  page;
  constructor(page) {
    this.page = page;
  }
  async send(message) {
    await sendMessage(this.page, message);
  }
  async toConversation(groupName, groupId) {
    await toConversation(this.page, groupName, groupId);
  }
};

// src/core/scrapeData.ts
async function scrapeData(page) {
  await page.click("#main-tab > div.nav__tabs__bottom > div:nth-child(3)");
  await page.waitForSelector("body > div.popover-v3");
  await page.click("body > div.popover-v3 > div.zmenu-body.has-submenu > div > div > div-14:nth-child(1)");
  await page.waitForSelector("#zl-modal__dialog-body");
  const [name, bio, birth, number] = await Promise.all([
    page.evaluate(() => document.querySelector(".pi-mini-info-section__name .truncate").textContent),
    page.evaluate(() => document.querySelector(".pi-info-section__info-list > div:nth-child(1) > div > span.content-copiable > div").textContent),
    page.evaluate(() => document.querySelector(".pi-info-section__info-list > div:nth-child(3) > div > span.content-copiable > p").textContent),
    page.evaluate(() => document.querySelector(".pi-info-section__info-list > div:nth-child(4) > div > span.content-copiable > p").textContent)
  ]);
  const cornerX = 0;
  const cornerY = 0;
  await page.mouse.click(cornerX, cornerY);
  const info = { name, bio, birth, number };
  return info;
}

// src/index.ts
var Client = class {
  page;
  events;
  actions;
  user;
  constructor(page) {
    this.page = page;
    this.user = null;
    this.events = new Events(page);
    this.actions = new Actions(page);
    this.setupEventListeners();
  }
  // Sets up event listeners, including 'initialized' event.
  setupEventListeners() {
    eventEmitter.once("initialized", async () => {
      this.user = await scrapeData(this.page);
      if (this.user) {
        store.dispatch(setName(this.user.name));
        store.dispatch(setBio(this.user.bio));
        store.dispatch(setBirth(this.user.birth));
        store.dispatch(setNumber(this.user.number));
        eventEmitter.emit("scraped");
      } else {
        throw new Error("Can't get user info");
      }
    });
  }
  // Registers a callback for the given event.
  async on(event, callback) {
    await this.events.on(event, callback);
  }
  // Registers a one-time callback for the given event.
  async once(event, callback) {
    await this.events.once(event, callback);
  }
  // Sends a message.
  async send(message) {
    try {
      await this.actions.send(message);
    } catch (error) {
      console.error("Error while sending message:", error);
    }
  }
  // Switches to a conversation/group chat.
  async toConversation(groupName, groupSelector) {
    try {
      await this.actions.toConversation(groupName, groupSelector);
    } catch (error) {
      console.error("Error while switching conversation:", error);
    }
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  init
});
