// node_modules/tsup/assets/esm_shims.js
import { fileURLToPath } from "url";
import path from "path";
var getFilename = () => fileURLToPath(import.meta.url);
var getDirname = () => path.dirname(getFilename());
var __dirname = /* @__PURE__ */ getDirname();

// src/core/init.ts
import puppeteer from "puppeteer";

// src/actions/toConversation.ts
async function toConversation(page, groupName, groupId) {
  const selector = "#main-tab > div:nth-child(1) > div.nav__tabs__top > div.clickable.leftbar-tab.flx.flx-col.flx-al-c.flx-center.rel.selected";
  await page.waitForSelector(selector);
  await page.click(selector);
  await page.type("#contact-search-input", groupName);
  await page.waitForSelector(groupId);
  await page.click(groupId);
}

// src/core/init.ts
import express from "express";
import http from "http";
import path2 from "path";
import { Server } from "socket.io";
import { EventEmitter } from "events";
var eventEmitter = new EventEmitter();
var app = express();
var server = http.createServer(app);
var io = new Server(server);
async function init(options) {
  const { groupName, groupID, headless = true, port = 3e3 } = options;
  let isLogin = false;
  app.set("view engine", "ejs");
  app.set("views", path2.join(__dirname, "../views"));
  app.use(express.static(path2.join(__dirname, "public")));
  try {
    const browser = await puppeteer.launch({ headless });
    const page = await browser.newPage();
    await page.goto("https://id.zalo.me/account?continue=https://chat.zalo.me");
    await page.waitForSelector("#app > div > div.zLogin-layout > div.body > div.animated.fadeIn.body-container > div.content.animated.fadeIn > div > div > div.qrcode > div.qr-container > img");
    ;
    const imageSrc = await page.evaluate(() => {
      const imgElement = document.querySelector("#app > div > div.zLogin-layout > div.body > div.animated.fadeIn.body-container > div.content.animated.fadeIn > div > div > div.qrcode > div.qr-container > img");
      if (imgElement) {
        return imgElement.src;
      } else {
        return null;
      }
    });
    app.get("/", (req, res) => {
      res.render("index", { imageSrc });
    });
    io.on("connection", (socket) => {
      console.log("a user connected");
      socket.on("refreshQR", async () => {
        console.log("Received refreshQR event");
        await page.reload();
      });
      page.on("request", (request) => {
        if (request.url().startsWith("data:image/png;base64")) {
          const imageSrc2 = request.url();
          io.emit("changeImage", imageSrc2);
        }
      });
    });
    page.on("framenavigated", async (frame) => {
      const url = frame.url();
      if (url.startsWith("https://chat.zalo.me/") && !isLogin) {
        isLogin = true;
        await toConversation(page, groupName, "#group-item-" + groupID);
        page.off("framenavigated");
        page.removeAllListeners("request");
        eventEmitter.emit("initialized");
      }
    });
    server.listen(port, () => {
      console.log(`Server is running on port http://localhost:${port}`);
    });
    return { browser, page };
  } catch (error) {
    console.error("Error during initialization:", error);
    throw error;
  }
}

// src/events/messageListener/getMessage.ts
import * as cheerio from "cheerio";

// src/state/store.ts
import { configureStore } from "@reduxjs/toolkit";

// src/state/userSlice.ts
import { createSlice } from "@reduxjs/toolkit";
var initialState = {
  name: "",
  bio: "",
  birth: "",
  number: ""
};
var userSlice = createSlice({
  name: "user",
  initialState,
  reducers: {
    setName: (state, action) => {
      state.name = action.payload;
    },
    setBio: (state, action) => {
      state.bio = action.payload;
    },
    setBirth: (state, action) => {
      state.birth = action.payload;
    },
    setNumber: (state, action) => {
      state.number = action.payload;
    }
  }
});
var { setName, setBio, setBirth, setNumber } = userSlice.actions;
var userSlice_default = userSlice.reducer;

// src/state/previousNameSlice.ts
import { createSlice as createSlice2 } from "@reduxjs/toolkit";
var initialState2 = {
  value: ""
};
var previousNameSlice = createSlice2({
  name: "previousName",
  initialState: initialState2,
  reducers: {
    setPreviousName: (state, action) => {
      state.value = action.payload;
    }
  }
});
var { setPreviousName } = previousNameSlice.actions;
var previousNameSlice_default = previousNameSlice.reducer;

// src/state/store.ts
var store = configureStore({
  reducer: {
    user: userSlice_default,
    previousName: previousNameSlice_default
  }
});

// src/events/messageListener/getMessage.ts
async function getMessage(page, user) {
  const previousName = store.getState().previousName.value;
  const elements = await page.evaluate(() => {
    const elements2 = document.querySelectorAll("[id*=bb_msg_id_]");
    return Array.from(elements2).map((element) => element.outerHTML);
  });
  const messages = elements.map((element) => {
    const $ = cheerio.load(element);
    const messageId = $(".chat-message").attr("id");
    const time = $(".card-send-time__sendTime").text().trim();
    let content;
    function getName() {
      const isMyMessage = $(".wrap-message").hasClass("me");
      if (isMyMessage) {
        return user?.name;
      } else {
        const senderNameElement = $(".card-sender-name span");
        if (senderNameElement.length > 0) {
          store.dispatch(setPreviousName(senderNameElement.text().trim()));
          return senderNameElement.text().trim();
        } else {
          return previousName;
        }
      }
    }
    const imageMessage = $("div.chatImageMessage");
    if (imageMessage.length > 0) {
      const imageSrc = $("img").attr("src");
      content = imageSrc;
    }
    const textMessage = $("div.card--text");
    if (textMessage.length > 0) {
      content = textMessage.find(".text").text().trim() || void 0;
    }
    const emojiElement = $(".emoji-sizer.emoji-outer.larger");
    if (emojiElement.length > 0) {
      const emojiCode = emojiElement.text();
      content = emojiCode;
    }
    const name = getName();
    return { content, name, messageId, time };
  });
  return messages;
}

// src/events/messageListener/index.ts
var messageArray = [];
function getAllMessage() {
  return messageArray;
}
async function messageListener(page, callback, user) {
  let isRunning = false;
  page.on("request", async (request) => {
    if (request.url().startsWith("https://tt-group-wpa.chat.zalo.me/api/group/deliveredv2?zpw_ver=628&zpw_type=30") && !isRunning) {
      const startTime = process.hrtime.bigint();
      isRunning = true;
      const message = await getMessage(page, user);
      await page.evaluate((message2) => {
        var elementsByClass = document.querySelectorAll(".rel.zavatar-container.avatar--overlay");
        elementsByClass.forEach(function(element) {
          element.remove();
        });
        const messageIdArray = message2.map((obj) => obj.messageId);
        messageIdArray.forEach(function(id) {
          if (id) {
            var element = document.getElementById(id);
            if (element) {
              var newId = id.replace("bb_msg_id_", "read");
              element.id = newId;
              var elementsById = document.querySelectorAll("[id*=read]");
              elementsById.forEach(function(element2) {
                element2.remove();
              });
            }
          }
        });
      }, message);
      if (message.length != 0 && message) {
        message.forEach((element) => {
          messageArray.push({
            content: element.content,
            name: element.name,
            messageId: element.messageId,
            time: element.time
          });
        });
        callback(message);
      }
      isRunning = false;
    }
  });
}

// src/events/index.ts
var Events = class {
  page;
  user;
  constructor(page) {
    this.page = page;
    this.user = null;
    this.connect();
  }
  connect() {
    eventEmitter.once("scraped", async () => {
      this.user = store.getState().user;
      eventEmitter.emit("ready");
    });
  }
  async on(event, callback) {
    switch (event) {
      case "message":
        eventEmitter.on("ready", () => messageListener(this.page, callback, this.user));
        break;
      default:
        console.log("It's something else.");
    }
  }
  async once(event, callback) {
    switch (event) {
      case "ready":
        eventEmitter.once("ready", () => callback());
        break;
      default:
        console.log("It's something else.");
    }
  }
};

// src/actions/send.ts
import * as path3 from "path";
async function sendMessage(page, options) {
  if (!options.message && !options.file || options.message && options.file) {
    throw new Error("Please provide either a message or a file, not both or none.");
  }
  if (options.message) {
    await sendMessageText(page, options.message);
  }
  if (options.file) {
    await sendFile(page, options.file);
  }
}
async function sendMessageText(page, message) {
  await page.waitForSelector("#input_line_0");
  await page.type("#input_line_0", message);
  await page.keyboard.press("Enter");
}
async function sendFile(page, filePath) {
  await page.waitForSelector("#ztoolbar > div:nth-child(2) > i");
  const [fileChooser] = await Promise.all([
    page.waitForFileChooser(),
    page.click("#ztoolbar > div:nth-child(2) > i")
  ]);
  const absolutePath = path3.resolve(filePath);
  await fileChooser.accept([absolutePath]);
}

// src/actions/index.ts
var Actions = class {
  page;
  constructor(page) {
    this.page = page;
  }
  async send(message) {
    if (message) {
      await sendMessage(this.page, message);
    } else {
      throw new Error("Type of message is", message);
    }
  }
  async toConversation(groupName, groupId) {
    if (groupId && groupName) {
      await toConversation(this.page, groupName, groupId);
    } else {
      throw new Error("Type of group Name or GroupID is undefined");
    }
  }
  async getAllMessage() {
    return getAllMessage();
  }
};

// src/core/scrapeData.ts
async function scrapeData(page) {
  await page.click("#main-tab > div.nav__tabs__bottom > div:nth-child(3)");
  await page.waitForSelector("body > div.popover-v3");
  await page.click("body > div.popover-v3 > div.zmenu-body.has-submenu > div > div > div-14:nth-child(1)");
  await page.waitForSelector("#zl-modal__dialog-body");
  const [name, bio, birth, number] = await Promise.all([
    page.evaluate(() => document.querySelector(".pi-mini-info-section__name .truncate").textContent),
    page.evaluate(() => document.querySelector(".pi-info-section__info-list > div:nth-child(1) > div > span.content-copiable > div").textContent),
    page.evaluate(() => document.querySelector(".pi-info-section__info-list > div:nth-child(3) > div > span.content-copiable > p").textContent),
    page.evaluate(() => document.querySelector(".pi-info-section__info-list > div:nth-child(4) > div > span.content-copiable > p").textContent)
  ]);
  const cornerX = 0;
  const cornerY = 0;
  await page.mouse.click(cornerX, cornerY);
  const info = { name, bio, birth, number };
  return info;
}

// src/index.ts
var Client = class {
  page;
  events;
  actions;
  user;
  constructor(page) {
    this.page = page;
    this.user = null;
    this.events = new Events(page);
    this.actions = new Actions(page);
    this.setupEventListeners();
  }
  // Sets up event listeners, including 'initialized' event.
  setupEventListeners() {
    eventEmitter.once("initialized", async () => {
      this.user = await scrapeData(this.page);
      if (this.user) {
        store.dispatch(setName(this.user.name));
        store.dispatch(setBio(this.user.bio));
        store.dispatch(setBirth(this.user.birth));
        store.dispatch(setNumber(this.user.number));
        eventEmitter.emit("scraped");
      } else {
        throw new Error("Can't get user info");
      }
    });
  }
  // Registers a callback for the given event.
  async on(event, callback) {
    await this.events.on(event, callback);
  }
  // Registers a one-time callback for the given event.
  async once(event, callback) {
    await this.events.once(event, callback);
  }
  // Sends a message.
  async send(message) {
    try {
      await this.actions.send(message);
    } catch (error) {
      console.error("Error while sending message:", error);
    }
  }
  // Switches to a conversation/group chat.
  async toConversation(groupName, groupSelector) {
    try {
      await this.actions.toConversation(groupName, groupSelector);
    } catch (error) {
      console.error("Error while switching conversation:", error);
    }
  }
  getAllMessage() {
    return this.actions.getAllMessage();
  }
};
export {
  Client as default,
  init
};
